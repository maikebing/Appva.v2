// <copyright file="OAuth2Tests.cs" company="Appva AB">
//     Copyright (c) Appva AB. All rights reserved.
// </copyright>
// <author>
//     <a href="mailto:johansalllarsson@appva.se">Johan Säll Larsson</a>
// </author>
namespace Appva.Test.OAuth2
{
    #region Imports.

    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.Diagnostics.CodeAnalysis;
    using System.Linq;
    using System.Net;
    using System.Security.Cryptography;
    using Core.Extensions;
    using DotNetOpenAuth.Messaging.Bindings;
    using DotNetOpenAuth.OAuth2;
    using DotNetOpenAuth.OAuth2.ChannelElements;
    using DotNetOpenAuth.OAuth2.Messages;
    using Newtonsoft.Json;
    using OAuth;
    using Tools;
    using Xunit;

    #endregion

    /// <summary>
    /// Test suite for <see cref="AuthorizationServer"/> and
    /// <see cref="ResourceServer"/>.
    /// <example>
    /// The certificates can be generated by:
    /// <code language="cs" title="Public/Private Key Generation Example">
    ///     var ca = Certificate.CertificateAuthority().Subject("CN=CA").CreateNew();
    ///     var c1 = Certificate.Code(ca).Subject("CN=AUTHSERVER").CreateNew();
    ///     var c2 = Certificate.Code(ca).Subject("CN=RESOURCESERVER").CreateNew();
    ///     var privateKey1 = c1.PrivateKey.ToXmlString(true).ToUtf8Bytes().ToBase64();
    ///     var publicKey1  = c1.PrivateKey.ToXmlString(false).ToUtf8Bytes().ToBase64();
    ///     var privateKey2 = c2.PrivateKey.ToXmlString(true).ToUtf8Bytes().ToBase64();
    ///     var publicKey2  = c2.PrivateKey.ToXmlString(false).ToUtf8Bytes().ToBase64();
    /// </code>
    /// </example>
    /// </summary>
    public sealed class OAuth2Tests
    {
        #region Variables.

        /// <summary>
        /// The <see cref="AuthorizationServer"/>
        /// </summary>
        private readonly AuthorizationServer authorizationServer;

        /// <summary>
        /// The <see cref="ResourceServer"/>
        /// </summary>
        private readonly ResourceServer resourceServer;

        #endregion

        #region Constructor.

        /// <summary>
        /// Initializes a new instance of the <see cref="OAuth2Tests"/> class.
        /// </summary>
        public OAuth2Tests()
        {
            this.authorizationServer = new AuthorizationServer(
                new OAuth2AuthorizationServer(
                    new OAuth2Service(OAuth2.AuthServerPrivateKey, OAuth2.ResourceServerPublicKey), 
                    new OAuth2CryptoStore(), 
                    new OAuth2NonceStore()));
            this.resourceServer = new ResourceServer(
                new StandardAccessTokenAnalyzer(
                    new AuthorizationServerSigningKeyHandler(OAuth2.AuthServerPublicKey).Provider,
                    new ResourceServerSigningKeyHandler(OAuth2.ResourceServerPrivateKey).Provider));
        }

        #endregion

        #region Tests.

        /// <summary>
        /// Test: Authorization for resource owner credentials.
        /// Expected Result: The access token is valid.
        /// </summary>
        [Fact]
        public void AuthorizeResourceOwnerCredentialGrant_ExpectIsAuthenticated()
        {
            var bearerToken = this.GetBearerToken(OAuth2.CreateAuthorization());
            var accestoken = this.GetAccessToken(bearerToken);
            Assert.Equal(OAuth2.Identifier, accestoken.ClientIdentifier);
            Assert.Equal(OAuth2.Username, accestoken.User);
        }

        /// <summary>
        /// Returns the access token.
        /// </summary>
        /// <param name="authorization">The basic authorization</param>
        /// <returns>The access token</returns>
        private BearerToken GetBearerToken(string authorization)
        {
            var request = HttpRequest.CreateNew(
                authorization,
                new NameValueCollection
                { 
                    { "scope", OAuth2.Scope },
                    { "grant_type", OAuth2.GrantType },
                    { "username", OAuth2.Username },
                    { "password", OAuth2.Password }
                });
            var response = this.authorizationServer.HandleTokenRequest(request);
            if (! response.Status.Equals(HttpStatusCode.OK))
            {
                throw new Exception("Bad request");
            }
            return JsonConvert.DeserializeObject<BearerToken>(response.Body);
        }

        /// <summary>
        /// Returns the access token.
        /// </summary>
        /// <param name="token">The bearer token</param>
        /// <returns>The access token</returns>
        private AccessToken GetAccessToken(BearerToken token)
        {
            var request = HttpRequest.CreateNew(token.Value);
            return this.resourceServer.GetAccessToken(request, OAuth2.Scope);
        }
        
        #endregion
    }

    #region Constants.

    /// <summary>
    /// Constants.
    /// </summary>
    [SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:FileMayOnlyContainASingleClass", Justification = "Reviewed.")]
    internal static class OAuth2
    {
        /// <summary>
        /// The authorization server private key.
        /// </summary>
        public const string AuthServerPrivateKey = "PFJTQUtleVZhbHVlPjxNb2R1bHVzPnErQlBQQ2hyZFBXem9EK2d1c3YzZ0FveDVDQTVMYnQxUEtRY2NZQ2dNWUg0Rm1lK1NUS29IMTBCajl3clRCUnAxTHN0dHAxMnFod0ZKVmFNNEMzUWp3OU9sT1pWMlpwR09iY0RJMHBqKzhJdkZ0Nmh0NVBMVEZDQWlRcXBhOXY5UEc4NkNRVWJTRVVvNEp5eG9KbVd3RFBjNE1iSFowL01GalFxblBYcU5mRG15VjVoTkwwMjhtc1gxQVZpMGMrNFZMN3hSKzdUenh4eVNDcE1vR2RsWW13Z016bkpIRkZjVmNnT1VQYkVqdkdpcmlYaDFnczhwVEd1TjI2SFRDaGFWZ2JUTFd3YmVVemVRREQyQW5KbG5hTnk3MFZLcHd3QURaemxCRDYrTkg0c2RzcktZa3YyVmlPRzJUeS9jcTdKQTlZdUhJRnBGK3o0WDlCcTZRNTdWdz09PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48UD4zTlgwVHFZdG5CbU5QYWNzT3ZjN091NHBZT2dpNW5vTTZYZFJBK1JRV3JBMlFlbDhnV3YreWZJNGE0M0FZb3VyY3JRM1JNZG1mdlpIT1g1blNGZXZXTGxmV0UvZE5QV1FtVUc4V1VNd2VTVk9QQVV0a3dVT3NHNVJiWUVoWllKaFN6bGJYMjcwVkJCSW1kTmc3VU4wMmFiaWt4SFZsSDA3RzNHMHY2ZGxyWXM9PC9QPjxRPnh6NlhTY25NMmJjWjhtTy9OWTF2WTNES0FiT1FyWTZVcnJGam96YXQ4YkxuMGRtbENCNWp0T0FPYjNnU3NJNGt6RUtSa3F4M283dEdSblZNbkppRVBZbGZlUitkVkpYaHFoYXZzMmNKNmZRN204aHF5ZGlyRTdnbjEwUDN2aXV5d2txelhQV0xhaWZIZHljOUVkK210U3pXMHhBUnAvTFlZeGdFV0J2eWV1VT08L1E+PERQPk9vaXZiK1ZXTTRrR1NmQTBwaEIvNzVmTytmT3R4SDlYU3M2b2Q2cWRyZHdGRmFWb3JmbE5HSVFPZGx1bFFibVpvUmFwaTU1NnlXNUg1TEpmZCtwZC9OdHRyVC9GOTFLYm1ETzNVOFdlWkk0QjFhRGR1cGxka21BN1R4WXFIdmpYQnhSVjVzN0hEajBlc1Q4NDhzcXRmejlmMFBHcU5laVhzU2VMYkQxWGt3OD08L0RQPjxEUT5vSmtCNXZjakNFWC9ReEpGZUV2MWdjalMrc1liRXRuL1hFUWRsTndwSHMzZTc1WW40TUJtQzlBaHNwV3RNdVNRSXBoeHNERVdDa0tVWll4ODRTaEtSek9vWWdBcWw1aHNHZVpKWHlqcG84czZGTnBad1RMRXlwTkFnZElHS2lJYzUyREE3R2Y3Sk9qRmJYU1NWQXJhMitRMWtGQytlb3BUQXFURU02VHJNVVU9PC9EUT48SW52ZXJzZVE+RlRMSzl6UHhpcnpJTVQyeXNKMlRpdHZLeSszWU8wOG1YZFJETGtUd0hFWlpVdUZXNEhOYzQxTHdxRk1Jb3J6T1NpYkp2Znk5TVNrekNyS1FOQ1NobTNxUzNlbjQ5eUd1WXhML1RCMEVZYUJGcXBPUWpnVVFXTjZxN1AzcjlObExTMnJLQ2IwSzh4VjJNaTQ0WWtKY085U2xGaU01bXQ4Y1BhVkRzNWRGOGEwPTwvSW52ZXJzZVE+PEQ+UkM4OVg4RXROLzROSDRKK2NmeGVtR1h5K3V3cG90SGVKWXQ1V1RITTJ6Y1RRMWd1cmYweG94ZVRlZzIvQTNTSnM0SDZGWnNNSzFub1ZMS3NPbmNTYU42S3J4bGRiM0Q3Y1FRQWM2eWNVNURxZTJrZ3dLSWFJWkZDSEp1bE1JdmFQM0prbEpWNUNFZWZldFBPeDhhR2ZvTlVtYnRoK2NNM1ZJdW5hQk5Lc2REVUpzWUVMY0tST2FMdFBlTlVNM1NIZ3ZJWkRJeUl0V1doU0orMFpXT1hMaGs1Wi9MR3JVOFVnNG5xM21FdmtpY0gxd05MRGoyVU1RcXQ2K0tMYkcyQ3A1K0dTV01mSUR2Ny9md3BFZjFPU2plYVNsYS9Fb0hVRDlNYlRGSFBwb2xNODhEVTBCMkhHYTlnc0V0TVFZVkhyVFNOeFFZS3R4L1liSzFlSi9UWG1RPT08L0Q+PC9SU0FLZXlWYWx1ZT4=";

        /// <summary>
        /// The authorization server public key.
        /// </summary>
        public const string AuthServerPublicKey = "PFJTQUtleVZhbHVlPjxNb2R1bHVzPnErQlBQQ2hyZFBXem9EK2d1c3YzZ0FveDVDQTVMYnQxUEtRY2NZQ2dNWUg0Rm1lK1NUS29IMTBCajl3clRCUnAxTHN0dHAxMnFod0ZKVmFNNEMzUWp3OU9sT1pWMlpwR09iY0RJMHBqKzhJdkZ0Nmh0NVBMVEZDQWlRcXBhOXY5UEc4NkNRVWJTRVVvNEp5eG9KbVd3RFBjNE1iSFowL01GalFxblBYcU5mRG15VjVoTkwwMjhtc1gxQVZpMGMrNFZMN3hSKzdUenh4eVNDcE1vR2RsWW13Z016bkpIRkZjVmNnT1VQYkVqdkdpcmlYaDFnczhwVEd1TjI2SFRDaGFWZ2JUTFd3YmVVemVRREQyQW5KbG5hTnk3MFZLcHd3QURaemxCRDYrTkg0c2RzcktZa3YyVmlPRzJUeS9jcTdKQTlZdUhJRnBGK3o0WDlCcTZRNTdWdz09PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPg==";

        /// <summary>
        /// The resource server private key.
        /// </summary>
        public const string ResourceServerPrivateKey = "PFJTQUtleVZhbHVlPjxNb2R1bHVzPm1kOFBEZ1NpTXE4TU0zR1lyUVpzM2xtMS9LUE1PbU1GN1BWUDBuUVdVMzlYUFpQSlFSSlhYZFdDL21zTkIwMkEvSWFxd1ltSzdGZGo4U3ZuUUxiVWlYTDJpbWNpcHI1amhtcGlMcU0vYnJPNFJJNU1JK2ZOclVLYnE4MzRkWUsxMzFrUndDM3RnVWxwZzUxMDR5d1pQSkY3dkFtTmdESHZLenEwcmZDYTNqdFUveEllRlRWb2Uwazh0KzhpT0FiYnRVbFBtYWR4MkZLeUtmT2hhTnRldEtFTjd2SEFZZ2RBTExtY2xqcDd5QnFOaEVDTnFSY29QdGNYeEZtM2F0SW54SlFnRzRNaDJTcENZdE52VnY0MlhIUjUxS3dxUGFHYmZybUR2cmtiQUZrVzlOYzA3Nm1RUEhSR3ZCN3lyV2NMaFpGMUxldyt0SWcvUzloWS9reUo0UT09PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48UD4rVHBteUxjY1ZETHV2L3dKaWF3TUQyZk1pbzhna2tlbGZUdWgzS0FKT0NnaWs2aHNNZElwNm9OK0N6ZXdVbUdhbnpHdWNDZkhMblhlWkltZkZ2dExGVkRWR3pyejc5elNUVUlvd1g5TUErbjdoa1JJMm10V1paWUJRTk9lQWF6T0tvVkVOSFVnOUc5SUJSQzBLY1M3NS9LdmhYZkt5bUl2OGFUck1keE5lbms9PC9QPjxRPm5nMWVKSEJ5dnVSTGtaVVp0QlBKVHFacEpZbCtYZUJoSjNJWDZnT0g1cWJ3RmEvb0NHMjhna0dCc0ptUm9pWXF3OFIxZmdLZG91TjVjUk90amF3SlF3ejllTHFSOEdmYnRTb3VLeHpQMnZjcHB3Y1YxR0t6UnBHRTVDNllPcThhU2dsSW1aaVJidWFCTERjQjc5anZseEMvQkR6NzNYVmR1SDl4MVQyd01Laz08L1E+PERQPjgxWm1UTXNjU2NtQStzb210ZGpaM2FESFFQSUdKMHowODVWcHNIUkJEQ2VEdXcvU3M4SXpVdG9ZRXZQSW9HYlVCV01Jb2xEMFZSU1lreWtiditDVHFyaEZtbFN4SUIxRzZGQVVZdmpiUzJjRlFrOGhvc0R5bGpVai9CdWlScGhtbzNXQzVvVUdMQ01LK29jWW9UK0pDQ3NYM1FUZFowVCs4cnpITnVPV2NtRT08L0RQPjxEUT5mTk94OXJXWTZvc0Q1QWNPTmRzcXNxTmJoL24vZzhVaTlqUjJEcXliT04rLzNtRC9zU2g2S2FYeTk3ZFIvZTZHOS9iQmxMUWNLL25jZ0NJNmdCblBkdFZibTI0K3ROQlNCZE02ZzNKTjkzSWR3MzBsRUlpamJxaWZmRmdRZ3Npb3lyQnFWbVRZOSsyMU4yWjZjU08wbG1yemNqVjM5b0FyZFB1eXUrZnNyNEU9PC9EUT48SW52ZXJzZVE+U2JTL1ZjWEk4eU5Mb09oY3VHdkFKck1Hb0lUREJmZHY5MWlLaVdZVldJMjZqSWI1ZXBPdVExSzArZ3l4S3Z6UkNzeFZqZE9PZW9MYng3WHFPUU1XTlhmQUI1V0V0RVR5dWFXdzk4c0FFa1dwS2wrdW5xdXc2Nmc3cWxHSW5XQ2s4TWhRSXFudkM5c3FJZkZ2dm5zVkUrUEgwWUF3VnNSMHB1Z2RGMzkyVEpvPTwvSW52ZXJzZVE+PEQ+T1g4aFdBS2hQVUV0MVBkSXJyYnM3WFVtVEw1RUxUa2RXTHNkMWEwdFBvd2g1RStaNzJmVUg2c041TlhKcTRYcGdmTXNVVjk4K3UxNDJnQ216QWJGaW9yYjEwSE1yL1FLcW9xTUg1TSt1N1lLVUF2QUpkYVRnMytWUGZDY1BBVFl3eG04U1V5Z0tDUnZlZy9YUXFBUzJoQWU1VmZJZVRPdmhEN09qd1NPU2lYWFgyeEhzVFhyU0pWT2gxTy9EcTZubmt2MTJUaDloWXdWcWVyUWRkSlY2QWg2UzlHVzhwL0RmMG4wMUlWdHZMdFdTSDRubHljNjAwem5Ra0pmVlk5b2RhUXpJMnJzRzNrR1NhdWpDZ1JUM2k3MmtZUFRjUktjQzhDVlVPbXlHazVBVU9yU1lQT0U0cmpoTG51VFNJNnpaVmw1RmU3VzNjSUJCQnpQci9sTXdRPT08L0Q+PC9SU0FLZXlWYWx1ZT4=";

        /// <summary>
        /// The resource server public key.
        /// </summary>
        public const string ResourceServerPublicKey = "PFJTQUtleVZhbHVlPjxNb2R1bHVzPm1kOFBEZ1NpTXE4TU0zR1lyUVpzM2xtMS9LUE1PbU1GN1BWUDBuUVdVMzlYUFpQSlFSSlhYZFdDL21zTkIwMkEvSWFxd1ltSzdGZGo4U3ZuUUxiVWlYTDJpbWNpcHI1amhtcGlMcU0vYnJPNFJJNU1JK2ZOclVLYnE4MzRkWUsxMzFrUndDM3RnVWxwZzUxMDR5d1pQSkY3dkFtTmdESHZLenEwcmZDYTNqdFUveEllRlRWb2Uwazh0KzhpT0FiYnRVbFBtYWR4MkZLeUtmT2hhTnRldEtFTjd2SEFZZ2RBTExtY2xqcDd5QnFOaEVDTnFSY29QdGNYeEZtM2F0SW54SlFnRzRNaDJTcENZdE52VnY0MlhIUjUxS3dxUGFHYmZybUR2cmtiQUZrVzlOYzA3Nm1RUEhSR3ZCN3lyV2NMaFpGMUxldyt0SWcvUzloWS9reUo0UT09PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPg==";

        /// <summary>
        /// The client identfier.
        /// </summary>
        public const string Identifier = "MIIB0TCCATqgAwIBAgIQFMDT/jJFUZJLkt2V44vuUDANBgkqhkiG9w0BAQUFADAU";

        /// <summary>
        /// The client name.
        /// </summary>
        public const string Name = "Test";

        /// <summary>
        /// The client secret.
        /// </summary>
        public const string Secret = "secret";

        /// <summary>
        /// The client scope.
        /// </summary>
        public const string Scope = "https://test.api.resource";

        /// <summary>
        /// The grant type.
        /// </summary>
        public const string GrantType = "password";

        /// <summary>
        /// The user id.
        /// </summary>
        public const string UserId = "admin";

        /// <summary>
        /// The user name.
        /// </summary>
        public const string Username = "admin";

        /// <summary>
        /// The user password.
        /// </summary>
        public const string Password = "password";

        /// <summary>
        /// Creates basic authorization.
        /// </summary>
        /// <returns>A basic authorization header string</returns>
        public static string CreateAuthorization()
        {
            return "{0}:{1}".FormatWith(Identifier, Secret).ToBase64();
        }
    }

    #endregion

    #region OAuth Helpers.

    /// <summary>
    /// The bearer token.
    /// </summary>
    [SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:FileMayOnlyContainASingleClass", Justification = "Reviewed.")]
    internal class BearerToken
    {
        /// <summary>
        /// The access token string.
        /// </summary>
        [JsonProperty("access_token")]
        public string Value
        {
            get;
            set;
        }

        /// <summary>
        /// The valid scopes.
        /// </summary>
        [JsonProperty("scopes")]
        public string Scopes
        {
            get;
            set;
        }
    }

    #endregion

    #region OAuth implementation.

    /// <summary>
    /// A <see cref="ICryptoKeyStore"/> implementations.
    /// </summary>
    [SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:FileMayOnlyContainASingleClass", Justification = "Reviewed.")]
    internal sealed class OAuth2CryptoStore : ICryptoKeyStore
    {
        #region Variables.

        /// <summary>
        /// The crypto keys.
        /// </summary>
        private static readonly IList<SymmetricCryptoKey> CryptoKeys = new List<SymmetricCryptoKey>();

        #endregion

        #region ICryptoKeyStore Members.

        /// <inheritdoc />
        public CryptoKey GetKey(string bucket, string handle)
        {
            return CryptoKeys.Where(x => x.Bucket == bucket && x.Handle == handle)
                .Select(x => new CryptoKey(x.Secret, x.ExpiresUtc)).SingleOrDefault();
        }

        /// <inheritdoc />
        public IEnumerable<KeyValuePair<string, CryptoKey>> GetKeys(string bucket)
        {
            return CryptoKeys.Where(key => key.Bucket == bucket).OrderByDescending(x => x.ExpiresUtc).ToList()
                .Select(key => new KeyValuePair<string, CryptoKey>(key.Handle, new CryptoKey(key.Secret, key.ExpiresUtc)))
                .ToList();
        }

        /// <inheritdoc />
        public void RemoveKey(string bucket, string handle)
        {
            var item = CryptoKeys.FirstOrDefault(x => x.Bucket == bucket && x.Handle == handle);
            if (item.IsNotNull())
            {
                CryptoKeys.Remove(item);
            }
        }

        /// <inheritdoc />
        public void StoreKey(string bucket, string handle, CryptoKey key)
        {
            CryptoKeys.Add(new SymmetricCryptoKey
            {
                Bucket = bucket,
                Handle = handle,
                Secret = key.Key,
                ExpiresUtc = key.ExpiresUtc
            });
        }

        #endregion
    }

    /// <summary>
    /// A symmetric cryptology key.
    /// </summary>
    [SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:FileMayOnlyContainASingleClass", Justification = "Reviewed.")]
    internal sealed class SymmetricCryptoKey
    {
        /// <summary>
        /// The bucket.
        /// </summary>
        public string Bucket
        {
            get;
            set;
        }

        /// <summary>
        /// The handle.
        /// </summary>
        public string Handle
        {
            get;
            set;
        }

        /// <summary>
        /// The expiration.
        /// </summary>
        public DateTime ExpiresUtc
        {
            get;
            set;
        }

        /// <summary>
        /// The secret.
        /// </summary>
        public byte[] Secret
        {
            get;
            set;
        }
    }

    /// <summary>
    /// A <see cref="INonceStore"/> implementation.
    /// </summary>
    [SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:FileMayOnlyContainASingleClass", Justification = "Reviewed.")]
    internal class OAuth2NonceStore : INonceStore
    {
        #region Variables.

        /// <summary>
        /// The nonces.
        /// </summary>
        private static readonly IList<Nonce> Nonces = new List<Nonce>();

        #endregion

        #region INonceStore Members

        /// <inheritdoc />
        public bool StoreNonce(string context, string nonce, DateTime timestampUtc)
        {
            var existingNonce = Nonces.SingleOrDefault(x => x.Context == context && x.Code == nonce && x.Timestamp == timestampUtc);
            if (existingNonce.IsNotNull())
            {
                return false;
            }
            Nonces.Add(new Nonce
            {
                Context = context,
                Code = nonce,
                Timestamp = timestampUtc
            });
            return true;
        }

        #endregion
    }

    /// <summary>
    /// The nonce.
    /// </summary>
    [SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:FileMayOnlyContainASingleClass", Justification = "Reviewed.")]
    internal sealed class Nonce
    {
        #region Properties.

        /// <summary>
        /// The nonce context.
        /// </summary>
        public string Context
        {
            get;
            set;
        }

        /// <summary>
        /// The nonce code.
        /// </summary>
        public string Code
        {
            get;
            set;
        }

        /// <summary>
        /// The nonce timestamp.
        /// </summary>
        public DateTime Timestamp
        {
            get;
            set;
        }

        #endregion
    }

    /// <summary>
    /// A <see cref="IOAuth2Service"/> implementation.
    /// </summary>
    [SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:FileMayOnlyContainASingleClass", Justification = "Reviewed.")]
    internal class OAuth2Service : IOAuth2Service
    {
        #region Variables.

        /// <summary>
        /// The authorizations.
        /// </summary>
        private static readonly IList<Authorization> Authorizations = new List<Authorization>();

        /// <summary>
        /// The clients.
        /// </summary>
        private static readonly IList<OAuth2Client> Clients = new List<OAuth2Client>
        {
            OAuth2Client.CreateNew(
                OAuth2.Identifier, 
                OAuth2.Name, 
                OAuth2.Secret, 
                null, 
                new HashSet<string> { OAuth2.Scope }, 
                (int) ClientType.Public)
        };

        /// <summary>
        /// The <see cref="AuthorizationServerSigningKeyHandler"/>.
        /// </summary>
        private readonly AuthorizationServerSigningKeyHandler authorizationServerSigningKeyHandler;

        /// <summary>
        /// The <see cref="ResourceServerSigningKeyHandler"/>.
        /// </summary>
        private readonly ResourceServerSigningKeyHandler resourceServerSigningKeyHandler;

        #endregion

        #region Constructor.

        /// <summary>
        /// Initializes a new instance of the <see cref="OAuth2Service"/> class.
        /// </summary>
        /// <param name="privateKey">The authorization private key</param>
        /// <param name="publicKey">The resourse server public key</param>
        public OAuth2Service(string privateKey, string publicKey)
        {
            this.authorizationServerSigningKeyHandler = new AuthorizationServerSigningKeyHandler(privateKey);
            this.resourceServerSigningKeyHandler = new ResourceServerSigningKeyHandler(publicKey);
        }

        #endregion

        #region IOAuth2Service Members

        /// <inheritdoc />
        public bool IsAuthorizationValid(IAuthorizationDescription authorization)
        {
            var createdAt = authorization.UtcIssued + TimeSpan.FromSeconds(10);
            var authorizations = Authorizations.Where(
                x => x.ClientId == authorization.ClientIdentifier
                && x.CreatedAt <= createdAt
                && (!x.ExpiresAt.HasValue || x.ExpiresAt.Value >= DateTime.UtcNow)
                && x.UserId == authorization.User).ToList();
            if (! authorizations.Any())
            {
                return false;
            }
            var isApproved = false;
            foreach (var auth in authorizations)
            {
                isApproved = authorization.Scope.IsSubsetOf(auth.Scopes);
            }
            return isApproved;
        }

        /// <inheritdoc />
        public AuthorizationServerAccessToken MintAccessToken(IAccessTokenRequest accessTokenRequest)
        {
            var accessToken = new AuthorizationServerAccessToken
            {
                ResourceServerEncryptionKey = this.resourceServerSigningKeyHandler.Provider,
                AccessTokenSigningKey = this.authorizationServerSigningKeyHandler.Provider
            };
            accessToken.ExtraData.Add("test", "test");
            return accessToken;
        }

        /// <inheritdoc />
        public IClientDescription FindClient(string clientIdentifier)
        {
            var client = Clients.SingleOrDefault(x => x.Identifier.Equals(clientIdentifier));
            if (client.IsNull())
            {
                throw new Exception("No client!");
            }
            return client;
        }

        /// <inheritdoc />
        public AutomatedUserAuthorizationCheckResponse CheckAuthorizeResourceOwnerCredentialGrant(IAccessTokenRequest accessRequest, string userName, string password)
        {
            var client = Clients.SingleOrDefault(x => x.Identifier.Equals(accessRequest.ClientIdentifier));
            if (client == null || (userName.NotEquals(OAuth2.Username) && password.NotEquals(OAuth2.Password)))
            {
                throw new Exception("Invalid credentials!");
            }
            var isApproved = accessRequest.Scope.IsSubsetOf(client.Scopes);
            if (isApproved)
            {
                Authorizations.Add(new Authorization()
                {
                    ClientId = accessRequest.ClientIdentifier,
                    UserId = OAuth2.UserId,
                    Scopes = accessRequest.Scope,
                    CreatedAt = DateTime.UtcNow,
                    ExpiresAt = DateTime.UtcNow.AddYears(100)
                });
                accessRequest.ExtraData.Add("firstname", "admin");
                accessRequest.ExtraData.Add("lastname", "adminsson");
            }
            return new AutomatedUserAuthorizationCheckResponse(accessRequest, isApproved, OAuth2.Username);
        }

        /// <inheritdoc />
        public AutomatedAuthorizationCheckResponse CheckAuthorizeClientCredentialsGrant(IAccessTokenRequest accessRequest)
        {
            var client = Clients.SingleOrDefault(x => x.Identifier.Equals(accessRequest.ClientIdentifier));
            if (client == null)
            {
                throw new Exception("Invalid credentials!");
            }
            var isApproved = accessRequest.Scope.IsSubsetOf(client.Scopes);
            if (isApproved)
            {
                accessRequest.ExtraData.Add("client", client.Name);
                Authorizations.Add(new Authorization()
                {
                    ClientId = accessRequest.ClientIdentifier,
                    UserId = client.Name,
                    Scopes = accessRequest.Scope,
                    CreatedAt = DateTime.UtcNow,
                    ExpiresAt = DateTime.UtcNow.AddDays(100)
                });
            }
            return new AutomatedAuthorizationCheckResponse(accessRequest, isApproved);
        }

        #endregion
    }

    /// <summary>
    /// Authorization.
    /// </summary>
    [SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:FileMayOnlyContainASingleClass", Justification = "Reviewed.")]
    internal sealed class Authorization
    {
        /// <summary>
        /// The client id.
        /// </summary>
        public string ClientId
        {
            get;
            set;
        }

        /// <summary>
        /// The user id. 
        /// </summary>
        public string UserId
        {
            get;
            set;
        }

        /// <summary>
        /// The authorized scopes.
        /// </summary>
        public HashSet<string> Scopes
        {
            get;
            set;
        }

        /// <summary>
        /// The authorization created at date time (UTC).
        /// </summary>
        public DateTime CreatedAt
        {
            get;
            set;
        }

        /// <summary>
        /// The authorization expiration at date time (UTC).
        /// </summary>
        public DateTime? ExpiresAt
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Responsible for providing the key to verify the token is intended for this 
    /// resource.
    /// </summary>
    [SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:FileMayOnlyContainASingleClass", Justification = "Reviewed.")]
    internal sealed class ResourceServerSigningKeyHandler
    {
        #region Variabels.

        /// <summary>
        /// The <see cref="RSACryptoServiceProvider"/>.
        /// </summary>
        private readonly RSACryptoServiceProvider cspProvider;

        #endregion

        #region Constructor.

        /// <summary>
        /// Initializes a new instance of the <see cref="ResourceServerSigningKeyHandler"/> class.
        /// </summary>
        /// <param name="key">The signing key</param>
        public ResourceServerSigningKeyHandler(string key)
        {
            this.cspProvider = new RSACryptoServiceProvider();
            this.cspProvider.FromXmlString(key.FromBase64().ToUtf8());
        }

        #endregion

        #region Public Properties.

        /// <summary>
        /// Returns the <see cref="RSACryptoServiceProvider"/>
        /// </summary>
        public RSACryptoServiceProvider Provider
        {
            get
            {
                return this.cspProvider;
            }
        }

        #endregion
    }

    /// <summary>
    /// Responsible for providing the key to verify the token came from the 
    /// authorization server.
    /// </summary>
    [SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:FileMayOnlyContainASingleClass", Justification = "Reviewed.")]
    internal sealed class AuthorizationServerSigningKeyHandler
    {
        #region Variabels.

        /// <summary>
        /// The <see cref="RSACryptoServiceProvider"/>.
        /// </summary>
        private readonly RSACryptoServiceProvider cspProvider;

        #endregion

        #region Constructor.

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthorizationServerSigningKeyHandler"/> class.
        /// </summary>
        /// <param name="key">The base64 signing key</param>
        public AuthorizationServerSigningKeyHandler(string key)
        {
            this.cspProvider = new RSACryptoServiceProvider();
            this.cspProvider.FromXmlString(key.FromBase64().ToUtf8());
        }

        #endregion

        #region Public Properties.

        /// <summary>
        /// Returns the <see cref="RSACryptoServiceProvider"/>
        /// </summary>
        public RSACryptoServiceProvider Provider
        {
            get
            {
                return this.cspProvider;
            }
        }

        #endregion
    }

    #endregion
}